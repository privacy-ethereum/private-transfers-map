[
  {
    "title": "Tornado Cash",
    "category": "Mixers",
    "website": "https://tornadocash.eth.limo/",
    "description": "<p>Decentralized Ethereum protocol designed to make token transfers private. Instead of privacy being the default, Tornado Cash offers opt-in privacy by allowing users to deposit assets into a smart contract and later withdraw them to a different address without publicly linking the two. It uses <strong>zk-SNARKs (zero-knowledge proofs)</strong> to achieve unlinkability between sender and receiver, providing privacy at the transaction level.</p><p><strong>It’s achievable by using:</strong></p><ol><li><strong>zk-SNARKs</strong> – enable users to prove ownership of a deposit without revealing which one, ensuring the withdrawal can't be traced back to the deposit</li><li><strong>Fixed-denomination anonymity sets</strong> – assets are deposited in fixed amounts (e.g., 0.1 ETH, 1 ETH, 10 ETH), and privacy increases as more users deposit the same amount into the same pool</li><li><strong>Relayer network</strong> – allows users to withdraw to a fresh wallet address without revealing their identity or paying gas from that address, preserving anonymity</li><li><strong>Non-custodial smart contracts</strong> – funds are locked in smart contracts with no central entity in control, reducing the need for trust</li><li><strong>Open-source deployment</strong> – the code is public and was deployed immutably, meaning no one (not even the developers) can alter or shut down the contracts</li><li><strong>Merkle trees and commitments</strong> – track private balances and preserve unlinkability between deposit and withdrawal</li></ol>",
    "logo": "/logos/mixers/tornado-cash.jpg",
    "pros": [
      "<strong>Strong cryptographic privacy</strong> – uses zk-SNARKs for robust anonymity guarantees",
      "<strong>Non-custodial</strong> – users retain full control of their funds; no trusted third party",
      "<strong>Open source and immutable</strong> – transparent code deployed on-chain, resistant to censorship",
      "<strong>Relayers</strong> – supports relayers for gasless withdrawals, enhancing anonymity during withdrawal",
      "<strong>Cross-chain support</strong> – deployed on Ethereum and other EVM-compatible chains"
    ],
    "cons": [
      "<strong>Opt-in privacy</strong> – users must actively use Tornado Cash to gain anonymity",
      "<strong>Fixed denominations</strong> – limits flexibility and transaction usability",
      "<strong>Regulatory risk</strong> – sanctioned by U.S. Treasury (OFAC), creating legal uncertainties",
      "<strong>Frontend removal</strong> – official frontends taken down, fragmenting user experience and reducing anonymity sets",
      "<strong>No ERC-20</strong> – doesn't support ERC-20 tokens (only native)"
    ]
  },
  {
    "title": "Tornado Cash Nova",
    "category": "Mixers",
    "website": "https://nova.tornadocash.eth.limo/",
    "description": "<p>Tornado Cash Nova is an upgraded privacy protocol built on Gnosis Chain (formerly xDai), designed to improve usability and flexibility. It retains the zero-knowledge privacy model but supports partial withdrawals and custom amounts, with lower fees and faster transactions.</p><p><strong>It's achievable by using:</strong></p><ol><li><strong>zk-SNARKs</strong> – adapted for an account-based privacy pool model rather than fixed pools</li><li><strong>Internal balances</strong> – allow partial withdrawals and internal transfers within the privacy pool without leaving it</li><li><strong>Gasless withdrawals via relayers</strong> – maintain full anonymity throughout the withdrawal process</li><li><strong>Low fees and fast finality</strong> – Gnosis Chain infrastructure reduces costs and speeds up transactions</li><li><strong>Merkle trees and commitments</strong> – track private balances and preserve unlinkability between deposit and withdrawal</li></ol>",
    "logo": "/logos/mixers/tornado-cash.jpg",
    "pros": [
      "Flexible amounts – supports deposits and withdrawals of any amount, not just fixed sizes",
      "Partial withdrawals – users can withdraw parts of their balance while maintaining privacy",
      "Low fees – leverages Gnosis Chain to reduce transaction costs",
      "Relayers – gasless withdrawals enhance privacy and user experience",
      "Non-custodial – maintains the core privacy guarantees of zk-SNARKs without trusting intermediaries",
      "ERC-20 support – supports ERC-20 tokens"
    ],
    "cons": [
      "Opt-in privacy – anonymity depends on user adoption and active use",
      "Smaller user base – fewer participants, limiting anonymity sets",
      "Regulatory concerns – potential reputational risk due to association with Tornado Cash",
      "Limited scope – focuses on transaction-level privacy, not full protocol or smart contract encryption"
    ]
  },
  {
    "title": "Privacy Pools",
    "category": "Mixers",
    "website": "https://privacypools.com/",
    "description": "<p>Privacy Pools is a next-generation privacy protocol for Ethereum and compatible chains, designed to enable selective private transactions while maintaining regulatory compliance. It builds upon concepts from Tornado Cash but introduces compliance-friendly innovations, like association sets and public verification, to offer privacy without shielding illicit activity (offers opt-in privacy by allowing users to deposit assets into a smart contract and later withdraw them to a different address without publicly linking the two).</p><p><strong>It’s achievable by using:</strong></p><ol><li><strong>zk-SNARKs</strong> – to prove that a user is part of a set of valid depositors without revealing which one</li><li><strong>Association sets</strong> – user-defined sets of \"acceptable\" depositors that a withdrawal can prove association with</li><li><strong>Merkle trees and commitments</strong> – track private balances and preserve unlinkability between deposit and withdrawal</li><li><strong>Ragequit mechanism</strong> – allows users to exit the system and reclaim funds if their association set becomes nonviable</li><li><strong>Modular ASP Layer</strong> – external providers curate deposit association sets for compliance filtering</li></ol>",
    "logo": "/logos/mixers/privacy-pools.svg",
    "pros": [
      "Regulatory-aware privacy – users can prove they belong to a compliant group of depositors",
      "Partial withdrawals – like Nova, users aren’t limited to fixed pool amounts",
      "Multi-asset support – supports ETH and ERC-20 tokens, unlike Tornado’s single-asset pools",
      "Non-custodial – retains user control with cryptographic guarantees",
      "Open source and modular – ASP system allows innovation without centralization"
    ],
    "cons": [
      "Opt-in privacy – effectiveness depends on widespread use and well-formed association sets",
      "Complexity – more advanced design requires deeper user understanding",
      "Smaller anonymity sets (early-stage) – currently less usage than Tornado Cash or mixers like Aztec",
      "Potential for misuse – though improved, still a privacy tool that may draw scrutiny from regulators",
      "UX still maturing – setup and use may be less intuitive for non-technical users"
    ]
  },
  {
    "title": "Veil Cash",
    "category": "Mixers",
    "website": "https://www.veil.cash/",
    "description": "<p>Veil Cash is a next-generation privacy protocol built on the Base network, enabling non-custodial, private transfers of ETH and ERC-20 tokens. Inspired by early privacy tools like Tornado Cash, it leverages zk-SNARKs to enable private deposits, transfers, and withdrawals, while introducing modern features like partial withdrawals, multi-asset support, and flexible user identities. It offers opt-in privacy by allowing users to deposit assets into a smart contract and later withdraw them to a different address without publicly linking the two.</p><p><strong>It’s achievable by using:</strong></p><ol><li><strong>zk-SNARKs</strong> – to prove membership in a private set of depositors without revealing which one, enabling unlinkable transfers and withdrawals</li><li><strong>Merkle trees and commitments</strong> – used to maintain a verifiable but private record of all deposits and transfers within the shielded pool</li><li><strong>Public and Private Keys (note-based model)</strong> – deposits generate a secret “note” (a private key) required to later spend or withdraw funds</li><li><strong>Compliance Verification (Optional)</strong> – supports integration with Ethereum Attestation Service or Coinbase-linked identities to prove \"verified\" users, potentially helping with regulatory clarity</li></ol>",
    "logo": "/logos/mixers/veil-cash.jpg",
    "pros": [
      "Selective privacy – users can send/receive assets privately, optionally disclosing or proving origin if needed (e.g., to verified partners)",
      "Partial withdrawals – unlike older privacy tools like Tornado Cash, users can deposit and withdraw arbitrary amounts, not just fixed denominations",
      "Non-custodial – no central intermediaries; users control their funds and keys throughout",
      "Staking and protocol revenue – VEIL token holders can stake to earn a share of protocol fees, incentivizing ecosystem growth",
      "Open source and decentralized – contracts are MIT-licensed and deployed without centralized control"
    ],
    "cons": [
      "Opt-in privacy – as with other privacy tools, effectiveness depends on the size of the anonymity set, low usage may reduce protection",
      "Experimental – still in early development; documentation warns users of potential risk and instability",
      "Complexity – managing keys, notes, and shielded transfers may be challenging for non-technical users",
      "Privacy vs compliance tension – while \"verified user\" features exist, Veil doesn’t yet have full association set filtering like Privacy Pools",
      "Regulatory scrutiny – as a privacy-focused protocol, it may still attract legal or compliance attention",
      "No ERC-20 – doesn't support ERC-20 tokens (only native)"
    ]
  },
  {
    "title": "Railgun",
    "category": "Shielded Pools (+DeFi)",
    "website": "https://www.railgun.org/",
    "description": "<p>Private transfers are limited in scope - the goal is to obfuscate amounts, sender, recipient, and other transaction metadata on-chain, so that only authorized parties (sender, recipient, and optionally an auditor) know the full details. However, certain metadata (e.g. transaction existence, gas usage, ordering) are still visible.</p><p><strong>It is achievable by using:</strong></p><ol><li><strong>Encrypted balances / ciphertexts / UTXO commitments</strong> - Railgun uses a UTXO-style commitment model: balances are represented by encrypted UTXOs in a Merkle tree of commitments (observers cannot see plaintext balances)</li><li><strong>ZK proofs</strong> - all private interactions (shielding, transfers, unshielding) are accompanied by zk-SNARK proofs that verify correctness (e.g. no overspending, consistency, valid state transitions) without revealing sensitive data</li><li><strong>Trusted setup</strong> - they use Groth16 circuits, requires a trusted setup</li><li><strong>Viewing / audit keys / shareable read-only key</strong> - Railgun offers a \"shareable read-only private key\" that can reveal the origin of funds if shared, enabling selective disclosure / audit.</li><li><strong>Commitment / ciphertext updates</strong> - new UTXO commitments, updated states, and proofs are stores on-chain</li><li><strong>Event monitoring</strong> - recipients or auditors scan events, filter those concerning them, and use decryption / viewing keys to interpret the transfers</li><li><strong>Private Proofs of Innocence (POI / PPI)</strong> - Railgun includes Private Proofs of Innocence: a mechanism to cryptographically prove that tokens being shielded are not coming from a known blacklist of bad actors, without revealing which tokens or addresses are involved. When a shield occurs, a POI proof is auto-generated. The protocol also enforces an Unshield-Only Standby Period (initially 1 hour) during which tokens in a new shield can only be unshielded (not further interacted with), allowing blacklist updates to propagate and reducing risk of rapid address hopping.</li></ol>",
    "logo": "/logos/shielded-pools/railgun.jpg",
    "pros": [
      "Amount privacy – 3rd parties cannot see how much was transferred",
      "Sender / recipient obfuscation / unlinkability – shielded UTXO pools make it difficult to trace flows",
      "Selective disclosure / auditability – shareable read-only private key enables optional transparency",
      "EVM Native – privacy built directly on existing EVM chains",
      "Composability – SDKs allow dApps to integrate private interactions",
      "Bad actor filtering via POI – private proofs reduce risk of blacklisted funds entering the system"
    ],
    "cons": [
      "Metadata leakage / structure leaks – timing, frequency, and patterns of transfers may still leak information",
      "Anonymity set / adoption dependency – privacy is weak if only a few users or transfers use the confidential mechanism",
      "Trusted setup – requires trusted setup for circuits, when new circuit designs or versions are introduced, new trusted setup and potential migration complexity arises",
      "Cost / complexity – generating and verifying proofs, managing UTXO states, cross‑contract calls, and encryption/decryption impose computational and gas overhead",
      "Delayed liquidity / cooldown periods – because of the Unshield‑Only standby period for POI, newly shielded funds may face delay before fully private interaction.",
      "POI partial trust / list dependency – POI depends on external list providers for known bad actors"
    ]
  },
  {
    "title": "Blanksquare",
    "category": "Shielded Pools (+DeFi)",
    "website": "https://blanksquare.io/",
    "description": "<p>Private transfers are limited in scope - the goal is to obfuscate amounts, sender, recipient, and other transaction metadata on-chain, so that only authorized parties (sender, recipient, and optionally an auditor) know the full details. However, certain metadata (e.g., transaction existence, gas usage, ordering) are still visible.</p><p><strong>It is achievable by using:</strong></p><ol><li><strong>Encrypted balances / shielded accounts / state commitments</strong> - uses account-based private state representations (not UTXO-style) where balances and state transitions are committed to via encrypted state commitments inside shielded pools</li><li><strong>ZK proofs</strong> - all interactions (shielding, transfers, withdrawals, etc.) are backed by zk-SNARK proofs</li><li><strong>Trusted setup</strong> - currently uses Groth16 circuits, which require a trusted setup</li><li><strong>Anonymity revokers / selective disclosure</strong> - optional on-chain or off-chain agents (e.g., regulated services, auditors) that can, under predefined rules, decrypt or trace shielded activity</li><li><strong>Shielded pool contract + proof storage</strong> - manages user privacy through Shielded Pool smart contracts, where encrypted state transitions and zk proofs are submitted on-chain</li><li><strong>Relayers</strong> - a relayer network submits transactions on behalf of users to prevent linkability from sender addresses or IPs</li><li><strong>Fraud protection + Shielder Guard</strong> - includes a mechanism to detect and prevent abuse, called Shielder Guard (combines behavior analytics, potential blacklisting, and integration with POI)</li></ol>",
    "logo": "/logos/shielded-pools/blanksquare.png",
    "pros": [
      "Amount privacy – 3rd parties cannot see how much was transferred",
      "Sender / recipient obfuscation / unlinkability – due to pooled shielding, it becomes challenging to link sender and receiver or trace flows",
      "Selective disclosure / auditability – users can reveal fund origins when needed using viewing keys",
      "EVM native – privacy built directly on EVM chains",
      "Composability – SDKs enable dApps and wallets to integrate private interactions",
      "Bad Actor Filtering via POI – reduces risk of illicit funds entering the system",
      "Real-time ZK proofs – emphasis on fast proof generation (~1 second) makes privacy practical for real-time usage",
      "No UTXO Complexity – uses account-based privacy, which avoids UTXO-style handling overhead and aligns with native EVM account models"
    ],
    "cons": [
      "Metadata leakage / structure leaks – timing, frequency, and patterns of transfers may still leak information",
      "Anonymity set / adoption dependency – privacy strength is correlated with the number of users utilizing the confidential mechanism",
      "Cost / complexity – managing shielded accounts, relayers and anonymity revoking mechanisms may introduce additional overhead",
      "Relayer trust assumptions – although relayers improve privacy, trusting relayers to behave properly (e.g. not colluding, not censoring) introduces risk"
    ]
  },
  {
    "title": "Labyrinth (Veilnyx)",
    "category": "Shielded Pools (+DeFi)",
    "website": "https://veilnyx.com/",
    "description": "<p>Private transfers are limited in scope - the goal is to obfuscate amounts, sender, recipient, and other transaction metadata on-chain, so that only authorized parties (sender, recipient, and optionally an auditor) know the full details. However, certain metadata (e.g., transaction existence, gas usage, ordering) are still visible.</p><p><strong>It is achievable by using:</strong></p><ol><li><strong>Shielded accounts / encrypted state commitments</strong> – uses an account-based encrypted model, where user balances, nonces, and activity are committed to inside a shielded pool (unlike UTXO-based models, accounts are persistent and programmable)</li><li><strong>ZK proofs</strong> – transactions (deposits, transfers, compliance disclosures) are backed by zk-SNARKS</li><li><strong>Trusted setup</strong> – currently relies on Groth16 circuits, requiring a trusted setup ceremony</li><li><strong>Selective disclosure via Decom</strong> – a decentralized compliance network (Decom) governs optional de-anonymization (through threshold encryption and access control policies, authorized third parties can request limited, rule-based data access)</li><li><strong>Shielded pool</strong> – all encrypted state, proofs, and user interactions are managed by a smart contract that enforces the shielded system logic and proof verification.</li><li><strong>Relayers</strong> – to avoid correlating sender identities or IP addresses, Labyrinth (Veilnyx) supports a network of relayers that submit transactions on behalf of users</li><li><strong>POI</strong> – through behavioral analysis and integration with external verification systems (like POI), Labyrinth (Veilnyx) filters illicit activity while maintaining user privacy</li></ol>",
    "logo": "/logos/shielded-pools/veilnyx.jpg",
    "pros": [
      "Amount privacy – 3rd parties cannot see how much was transferred",
      "Sender / recipient obfuscation / unlinkability – pooled shielding makes tracing difficult",
      "Persistent account model – avoids UTXO complexity using programmable accounts",
      "Programmable compliance – selective disclosure via view keys or compliance attestations",
      "EVM native – operates on standard EVM chains",
      "DeFi-ready adapters – drop-in privacy support for common dApp patterns",
      "Modular and scalable – circuits, compliance rules, and relayers are modular",
      "Cross-chain and AA support – integrates with account abstraction and multichain deployments"
    ],
    "cons": [
      "Metadata leakage / structure leaks – timing, frequency, and behavioral patterns may still leak data",
      "Anonymity set / adoption dependency – privacy improves with more users",
      "Cost / complexity – managing shielded accounts, relayers and anonymity revoking mechanisms may introduce additional overhead",
      "Relayer trust assumptions – although relayers improve privacy, trusting relayers to behave properly (e.g. not colluding, not censoring) introduces risk"
    ]
  },
  {
    "title": "Tongo",
    "category": "Shielded Pools (+DeFi)",
    "website": "https://www.tongo.cash/",
    "description": "<p>Private transfers are limited in scope - the goal is to obfuscate amounts (and optionally recipient) on-chain so that only authorized parties (sender, recipient, and optionally an auditor) know the full details. However, certain metadata (e.g. transaction existence and the sender) are still visible.</p><p><strong>It’s achievable by using:</strong></p><ol><li><strong>Encrypted balances / ciphertexts</strong> - accounts hold balances as encrypted values (via ElGamal) rather than plaintext on chain</li><li><strong>Zero-knowledge proofs</strong> - for each transfer or balance update, proofs ensure correctness (no overspending, conservation of totals) without revealing plaintext amounts</li><li><strong>Viewing / audit keys / decryption keys</strong> - users hold keys (or derive them) that allow them (or a designated auditor) to decrypt or verify their own transactions / balances</li><li><strong>Commitments / ciphertext updates on chain</strong> - encrypted state or commitments are published on chain to guarantee integrity</li><li><strong>Event / state monitoring + decryption</strong> - recipients (or auditors) scan relevant contract events or state changes and use their decryption / viewing keys to detect and interpret transfers</li></ol>",
    "logo": "/logos/shielded-pools/tongo.jpg",
    "pros": [
      "Amount privacy - third parties cannot see how much was transferred",
      "Optional recipient privacy / unlinkability - receiver identity or sender-receiver linkage can be hidden or obfuscated",
      "Audit / selective disclosure - supports optional compliance through auditor or user-controlled disclosure",
      "No trusted setup - uses ECC + proof systems without multi-party setup",
      "Compatibility / composability - built for Starknet and compatible with token standards"
    ],
    "cons": [
      "Sender visibility (likely) - the transaction originator is generally visible unless explicitly masked",
      "Metadata leakage / structure leaks - timing, frequency, and patterns of transfers may still leak information",
      "Anonymity set / adoption dependency - privacy is weak if only a few users or transfers use the confidential mechanism",
      "Complex cryptography / cost - proof generation, encryption/decryption, and gas overhead",
      "Key management burden - users must securely manage secret and viewing keys",
      "Disclosure trade-offs - revealing keys or transactions forfeits privacy"
    ]
  },
  {
    "title": "Zama",
    "category": "Shielded Pools (+DeFi)",
    "website": "https://www.zama.org/",
    "description": "<p>Private transfers are limited in scope - the goal is to hide amounts and balances so that only authorized parties (sender, recipient, and optionally an auditor) know the full details. However, certain metadata (e.g. transaction existence and the sender and the receiver) are still visible.</p><p><strong>It’s achievable by using:</strong></p><ol><li><strong>N</strong><strong>FHE</strong> - transfer amounts and balances stay encrypted in ciphertext form</li><li><strong>ZK Proofs</strong> - to ensure that encrypted inputs are valid without revealing them</li><li><strong>Threshold decryption / MPC-based Key Management Service (KMS)</strong> - decryption keys are split among multiple parties; no single party can decrypt alone.</li><li><strong>Access control logic in smart contracts</strong> - contracts specify who is allowed to decrypt which values.</li><li><strong>Symbolic execution + off-chain coprocessors</strong> - the chain emits pointers/events and off-chain nodes compute on the encrypted data, then return results.</li></ol>",
    "logo": "/logos/shielded-pools/zama.jpg",
    "pros": [
      "Amount / Balance privacy - amounts, balances, and contract state are confidential by default to unauthorized observers",
      "ACL for operations - developers can define who has decryption rights",
      "Composability - confidential and non-confidential contracts are composable and compatible",
      "EVM native solution - operates as an overlay layer on existing L1/L2s",
      "No trusted setup - ZK is used only for input correctness and keys are managed with MPC"
    ],
    "cons": [
      "Not fully private - sender and receiver are still visible",
      "Metadata leakage - timing, frequency, and sequence of encrypted operations may leak information",
      "Infrastructure complexity - requires coprocessors, MPC nodes, gateway, etc.",
      "Cost and performance - FHE operations, MPC coordination, and ZK proofs incur high costs",
      "Adoption / anonymity set - privacy improves with usage; low adoption weakens privacy",
      "Disclosure trade-offs - revealing keys or decrypted values forfeits privacy",
      "Decryption request / ACL visibility - decryption requests and access-policy checks are public, leaking metadata"
    ]
  },
  {
    "title": "Inco",
    "category": "Shielded Pools (+DeFi)",
    "website": "https://www.inco.org/",
    "description": "<p>Private transfers are limited in scope - the goal is to hide amounts and balances so that only authorized parties (sender, recipient, and optionally an auditor) know the full details. However, certain metadata (e.g. transaction existence and the sender and the receiver) are still visible but claim that Inco Atlas will hide sender and receiver as well (not ready yet).</p><p><strong>It’s achievable by using:</strong></p><ol><li><strong>TEEs</strong> – in Inco Lightning, computations are done inside secure hardware enclaves, which keep data encrypted and hidden from node operators.</li><li><strong>FHE</strong> – data remains encrypted (ciphertext) during computation; no plaintext ever appears on-chain or off-chain (planned in Inco Atlas)</li><li><strong>ZK proofs</strong> – used to prove correctness of encrypted inputs or computation outcomes without revealing the inputs themselves</li><li><strong>MPC-based KMS (Key Management)</strong> – decryption keys are split among multiple parties (no single entity can decrypt alone)</li><li><strong>Programmable ACL</strong> – smart contracts define fine-grained rules on who can request and receive decrypted data, embedded in contract logic.</li><li><strong>Off-chain Confidential Coprocessors</strong> – TEEs or MPC nodes compute off-chain on encrypted data and return proofs/results back on-chain</li></ol>",
    "logo": "/logos/shielded-pools/inco.jpg",
    "pros": [
      "Amount / Balance privacy – transfer amounts, balances, and confidential contract states remain encrypted",
      "ACL for Operations – developers can define access policies for decryption and disclosure",
      "Composability – confidential and non-confidential logic can be mixed in EVM-compatible contracts",
      "EVM Native – works as a confidentiality layer on top of EVM chains",
      "Upgradeable cryptography – modular design allows future upgrades (e.g., replacing TEEs with FHE)"
    ],
    "cons": [
      "Not fully private – sender and recipient addresses are still visible on-chain (especially in TEE-based Lightning mode).",
      "Metadata leakage – timing, frequency, and sequence of encrypted operations may reveal patterns",
      "Infrastructure complexity – requires a network of specialized nodes: TEEs (for Lightning) or MPC/FHE nodes (for Atlas), bridge relays and off-chain coprocessors",
      "Cost and performance – TEE operations are faster but rely on trusted hardware; FHE and MPC (Atlas) modes are significantly slower and more computationally expensive",
      "Adoption / anonymity set – privacy improves with more users; low adoption weakens privacy",
      "Disclosure trade-offs – revealing decryption keys or decrypted values forfeits privacy",
      "Decryption request / ACL visibility – although data is encrypted, decryption requests are public, and policies must be enforced publicly, which leaks metadata (who requested decryption, when)"
    ]
  },
  {
    "title": "WORM",
    "category": "zkWormholes",
    "website": "https://worm.cx/",
    "description": "<p>An app to use wormholes in the application layer rather than on the protocol layer. It keeps the logic of:</p><ol><li>burn ETH from address 0x1 with a proof that it has sent to an unspendable address</li><li>proof contains the amount of ETH burned = amount of BETH (Burned ETH)</li><li>Use proof to mint WORM with address 0x2</li><li>Swap WORM -> ETH with address 0x2</li></ol><p>As you can see, there is impossible to link address 0x1 to 0x2</p>",
    "logo": "/logos/zkWormholes/worm.jpg",
    "pros": [
      "Amount privacy - tokens burned and tokens mint are visible to everybody. But the origin of those tokens remains private",
      "Recipient privacy - the identity of the receiver or sender-receiver link is hidden because any wallet can use a PPoB proof to mint tokens",
      "Audit / selective disclosure - users can save PPoB locally and show proofs of specific transactions if authorities require them",
      "No external trust assumption - everything happens on-chain; proof generation may require external devices or services but trust isn't required",
      "Compatibility / composability - minted tokens are native and easily integrable with dApps",
      "Compliance - can integrate Proof-of-Innocence or on-chain third-party checks for regulatory compliance",
      "Deployment complexity - no protocol changes required; anyone can deploy a similar app on any EVM quickly"
    ],
    "cons": [
      "Liquidity - relies on sufficient WORM/ETH liquidity for safety",
      "Competition - protocol-layer wormholes or competitor dApps could reduce WORM adoption",
      "Cryptography risk - collisions between EOAs and zkwormhole addresses may be possible with high but finite attack cost",
      "Anonymity set - privacy depends on number of users; small usage makes deposit-withdraw mapping easier",
      "Broken anonymity set on the future - analysis techniques focused on single transfered addresses (burn addresses) could deanonymize users over time"
    ]
  },
  {
    "title": "Scroll experiment with EIP-7503",
    "category": "zkWormholes",
    "website": "https://www.notion.so/scrollzkp/WIP-Wormhole-RIP-2817792d22af80029818ee83cb1c54ba",
    "description": "<p>Scroll tried to implement EIP-7503 into their rollup protocol (not in the app layer but in the protocol layer) but they found a couple of issues with the EIP itself. They stated that it is not as secure as possible.</p>",
    "logo": "/logos/zkWormholes/scroll.jpg",
    "pros": [
      "General - Same as above (WORM implementation)",
      "Deployment complexity - L2s could create a native mechanism (e.g. precompile) for PPoB private transfers; easier to develop and deploy on L2 than on L1"
    ],
    "cons": [
      "General - Same as above (WORM implementation)",
      "An error in the L2 implementation could allow infinite mint of tokens (ETH or others), potentially propagating to L1 if not caught in time"
    ]
  },
  {
    "title": "Grantee tried to integrate EIP-7503 in Berachain",
    "category": "zkWormholes",
    "website": "https://github.com/okwme/eip-7503-chain",
    "description": "<p>It looks like a grant project that was done independently from the Berachain devs. I think it is interesting to look at because it might be \"simple\" to integrate EIP-7503 into EVM rollups code. More info in: https://devfolio.co/projects/eipchain-e85d</p>",
    "logo": "/logos/zkWormholes/berachain.png",
    "pros": [
      "Showcase a EIP-7503 implementation is possible in another rollup besides Scroll"
    ],
    "cons": [
      "No follow up. Looks like a grantee or hackathon project",
      "Polaris Berachain EVM is discontinued so this code is deprecated"
    ]
  },
  {
    "title": "ZK Token Wrapper (ERC-8065)",
    "category": "zkWormholes",
    "website": "https://ethereum-magicians.org/t/erc-8065-zero-knowledge-token-wrapper/26006",
    "description": "<p>This token wrapper aims to bring the zkWormhole idea (Private Proof of Burn - PPoB) into any existing token in the Ethereum ecosystem (including ERC-20, ERC-721, ERC-1155 and ERC-6909). In the non-fungible scenarios only the owner of the asset is hidden because each token is unique and there cannot be a coin-mixing functionality. Users will be able to wrap their tokens into a zk proof to break the link between the sender and the recipient. The proposal suggests two workflows:</p><ol><li><strong>ZKW Token-aware workflow:</strong> the user can use the ZKWTokens (representation of the burnt tokens) as if they were the original tokens. For example, if the underlying token is ERC-20, ZWToken can be traded on DEXs, used for swaps, liquidity provision, or standard transfers.</li><li><strong>ZKW Token-unaware workflow:</strong> the user A burns his tokens (e.g. ERC-20) and send the PPoB to user B to redeem ZKWTokens on its end. Then he swaps ZKW Tokens with original tokens (e.g. ERC-20) and he can use them as normal tokens.</li></ol>",
    "logo": "/logos/zkWormholes/ZWToken.svg",
    "pros": [
      "Public amount: when shielding / burning tokens, the amount is visible because it is an on-chain transaction sending N tokens to a specific address proven to be unspendable",
      "Public sender: the on-chain transaction shows the sender address and its balance history",
      "Private recipient: after burning tokens, the PPoB can be redeemed from any wallet, breaking sender-recipient linkage",
      "No external-trust assumption: no external service provider or coprocessor is required",
      "Compliance: Proof of Innocence at the entry contract and selective disclosure stored client-side",
      "Compatibility: ZKW Tokens remain compatible with existing Ethereum ecosystem depending on the underlying token"
    ],
    "cons": [
      "Same as above: this is basically the same as WORM",
      "Multiple tokens liquidity: privacy depends on liquidity per token; low-liquidity pools make deposit-withdraw mapping easier"
    ]
  },
  {
    "title": "Mirage",
    "category": "Obfuscators",
    "website": "https://www.mirageprivacy.com/",
    "description": "<p>Aims to provide permissionless, probabilistic privacy on Ethereum by making on-chain contract logic and transaction flows harder to analyze so that sensitive links and intents become costly or ambiguous for observers.</p><p><strong>It's achievable by using:</strong></p><ol><li><strong>Deterministic EVM bytecode obfuscation (Azoth)</strong> – rewrite/transform contract bytecode so on-chain execution patterns and dataflow are harder to reverse-engineer while remaining verifiable and reproducible</li><li><strong>Worker nodes / agents (Nomads)</strong> – off-chain agents that perform coordination, apply obfuscation tooling and help manage protocol flows (with specified roles and incentives)</li><li><strong>On-chain escrow / incentive contracts</strong> – smart contracts that lock collateral and manage payments to Nomads to align incentives and penalize misbehavior</li><li><strong>Probabilistic privacy model</strong> – privacy is achieved by increasing the effort and ambiguity of analysis rather than providing absolute cryptographic secrecy</li><li><strong>Deterministic transformations + auditability</strong> – obfuscation is deterministic so others can reproduce/verify transformations while still hiding semantic structure</li><li><strong>Composability with existing Ethereum contracts</strong> – obfuscated contracts remain EVM-native and interoperable with the rest of the ecosystem</li></ol>",
    "logo": "/logos/obfuscators/mirage.jpg",
    "pros": [
      "Ethereum-native – works on L1 without requiring new chains or consensus rules",
      "Lower explicit trust assumptions – relies on incentives and on-chain contracts instead of trusted authorities",
      "Practical and deployable – uses engineering approaches without heavy SNARK/STARK requirements",
      "Verifiable determinism – deterministic obfuscation allows reproducibility and auditability",
      "Incentive alignment via escrow – economic incentives and penalties maintain node reliability"
    ],
    "cons": [
      "Not full cryptographic privacy – obfuscation increases difficulty but leakage remains possible",
      "Probabilistic guarantees – privacy is statistical and weaker against motivated attackers",
      "Dependence on anonymity set and adoption – small or predictable use weakens privacy",
      "Operational and gas overheads – obfuscation and Nomad coordination increase costs",
      "New attack surface (off-chain nodes) – Nomads introduce potential collusion or misbehavior risks",
      "Metadata from deployment and registry – publishing obfuscated contracts or node info may leak metadata",
      "User/developer hygiene matters – poor operational practices can erase privacy gains",
      "Security audits and verification – difficult to audit obfuscated contracts",
      "Not production ready – early stage, limited documentation. It looks like it is still in research phase"
    ]
  },
  {
    "title": "Unlink",
    "category": "Obfuscators",
    "website": "https://www.unlink.xyz/",
    "description": "<p>Aims to provide seamless, protocol-level privacy on Ethereum by enabling private transactions through intents, escrow contracts, and solver networks, all integrated via SDKs into existing wallets and infrastructure. Focuses on making privacy usable at scale, so that unlinking transactions becomes the default rather than an exception.</p><p><strong>It's achievable by using:</strong></p><ol><li><strong>Intent-based escrow contracts</strong> – users deposit into an escrow contract that holds funds while waiting for a matching solver to execute the intent, enabling private settlement without direct on-chain linkage</li><li><strong>Relayers</strong> – off-chain agents that receive the user's intent, perform compliance checks, blind the intent, and submit it to the solver network</li><li><strong>Solver network</strong> – decentralized network of agents that execute the user's intent on-chain and are compensated from the escrow, ensuring unlinkability between sender and recipient</li><li><strong>Instant execution and composability</strong> – unlinking occurs within a single transaction flow; recipients receive instantly with no deposit/withdraw patterns, compatible with any token</li><li><strong>Standard denominations and timing</strong> – uses fixed transaction sizes and obfuscated timing to increase ambiguity and strengthen the anonymity set</li><li><strong>SDK integration</strong> – Unlink is a tooling-layer SDK that integrates directly into wallets, infrastructure, and apps, letting users toggle privacy without extra wallets, chains, or setup</li></ol>",
    "logo": "/logos/obfuscators/unlink.jpg",
    "pros": [
      "EVM native - operates on Ethereum L1 without new chains or bridges",
      "Easy integration - SDK plugs into wallets, infra, and dApps for private transactions",
      "Instant and composable - no deposit/withdraw cycles and instant UX",
      "Compliance - relayers enforce compliance checks before blinding intents",
      "Adoption = stronger privacy – large-scale usage expands anonymity set"
    ],
    "cons": [
      "Not full cryptographic privacy - relies on probabilistic unlinkability",
      "Anonymity set = adoption - low volume weakens privacy",
      "Relayer trust - off-chain actors may collude or misbehave; economic, not cryptographic mitigation",
      "Early-stage - no code or documentation available yet",
      "Metadata leakage – external wallet/gas/social patterns can still reveal identity",
      "Operational complexity – relayer, solver, and escrow coordination add overhead"
    ]
  },
  {
    "title": "Brume",
    "category": "Wallets",
    "website": "https://wallet.brume.money/",
    "description": "<p>It is a browser wallet and a browser extension wallet that hides your IP using Tor. I will consider it in the private reads world. There is no mention to private transfers.</p>",
    "logo": "/logos/wallets/brume.png",
    "pros": [
      "Web browsing privacy: Built-in TOR to hide IP address; each account has its own IP",
      "Distributed redundant communication: one blockchain state request to multiple servers to ensure nobody is lying"
    ],
    "cons": [
      "Lack of documentation: no available docs, only one diagram showing Tor integration for IP protection"
    ]
  },
  {
    "title": "ZkBob",
    "category": "Wallets",
    "website": "https://docs.zkbob.com/",
    "description": "<p>A stablecoin-based privacy smart contract wallet (AA) deployed on Polygon and Optimism. Hides senders, receivers and amounts when transferring tokens. It integrates compliance features like daily limits, KYC, and more. They use a relayer to abstract gas fees and make it easy for users to interact with the wallet.</p><p>It works by depositing tokens into a pool and using zk proofs to move those funds inside the pool. Transfers are hidden because zk proofs update the shielded state without revealing details. One account can have multiple public addresses to send hidden tokens, preventing linkage between transactions. Only the owner knows these addresses are linked. The relayer sees nothing except zk proofs.</p>",
    "logo": "/logos/wallets/zkBob.svg",
    "pros": [
      "Full privacy over sender, receiver, and balance: once funds are in the pool, all transfers are fully hidden via zk proofs",
      "Gasless via relayer: users do not need native tokens to pay gas, improving UX and unlinkability",
      "No external trust assumption: system does not require external MPC or FHE co-processors",
      "Compliance: supports deposit/withdraw limits, optional KYC for higher limits, and address screening (e.g., TRM Labs)"
    ],
    "cons": [
      "High gas costs: limited to Optimism and Polygon likely due to zk proof costs",
      "Few tokens available: only USDC, ETH, and BOB pools exist; new tokens require new pool deployments",
      "Anonymity set: privacy strength depends on pool size; low usage weakens protection",
      "Metadata leakage: timing, frequency, and deposit/withdraw patterns may still enable correlation attacks"
    ]
  },
  {
    "title": "Payy (L2 on Ethereum)",
    "category": "Wallets",
    "website": "https://docs.payy.network/product/payy-network",
    "description": "<p>It is currently implemented as a bespoke single-sequencer validium rollup on Polygon (Ethereum soon). It aggregates UTXO transaction proofs and hashes submitted by Payy Wallet and posts them to the base layer.</p><p>When you send a Payy Link or QR, funds are transferred from your wallet to a new ephemeral wallet embedded in the link. When someone claims the link, those funds are transferred out from the ephemeral wallet to their Payy wallet.</p><p>During both UTXO transactions, the actual payment data never leaves your device. It is cryptographically impossible for someone to infer the payment amount, sender, or recipient by watching the network. Even your Payy Address is never exposed.</p><p>This happens because the only data that leaves your device is an updated state hash and a zk proof. More technical details are in the whitepaper.</p>",
    "logo": "/logos/wallets/payy.jpg",
    "pros": [
      "Private sender and receiver: client builds UTXO proofs locally and only transmits zk proofs + state hashes",
      "Linkage resistance: ephemeral wallets + UTXO notes prevent linking transactions across addresses",
      "Data minimization: only proofs and succinct hashes are on-chain, reducing gas costs",
      "On-device privacy: sensitive data never leaves the device, protecting against network-level adversaries",
      "Compliance-friendly: supports UTXO lineage checks, privacy pools, and Proof of Innocence"
    ],
    "cons": [
      "L2 isolation: tokens must be bridged; currently focused on stablecoins",
      "Data availability risk: off-chain storage of UTXO data introduces dependency on operator availability"
    ]
  },
  {
    "title": "Hinkal",
    "category": "Wallets",
    "website": "https://hinkal-team.gitbook.io/hinkal",
    "description": "<p>Wallet that uses smart contracts, stealth addresses, UTXO models, and zk proofs to maintain an encrypted private balance and allow users to privately send transactions between encrypted pool members. Users deposit funds to stealth addresses (unlinkable), and withdraw via zk proofs showing sufficient encrypted balance.</p>",
    "logo": "/logos/wallets/hinkal.avif",
    "pros": [
      "Private sender, receiver, and balance: uses zk-proofs and UTXO models where only proofs are on-chain",
      "Gas abstraction: relayers allow gasless transactions",
      "Composability with DeFi: supports private swaps, staking, and lending via integrations (Uniswap, AAVE, Lido, etc.)",
      "Compliance: includes KYC gating, blacklist screening, zkMe attestations, and anonymous staking"
    ],
    "cons": [
      "Compliance undermines full anonymity: the requirement to pass KYC (via aiPrise / external provider) before accessing the shielded pool means not everyone can be anonymized. Users who cannot/do not want to do KYC are excluded, reducing potential anonymity set. Also, the access-token architecture is a single point where PII and wallet linkage might be revealed under legal demands.",
      "Relayer trust / centralization risk: centralized or malicious relayers may censor or reduce liveness",
      "Anonymity set: privacy depends heavily on pool size; low usage weakens protection"
    ]
  },
  {
    "title": "Kohaku",
    "category": "Wallets",
    "website": "https://notes.ethereum.org/@niard/KohakuRoadmap",
    "description": "<p>The EF's official privacy-focused wallet. It will contain multiple plugins to enable different privacy protocols (starting with Railgun, Privacy Pools, etc.). This will be both a wallet and an SDK so other wallets can integrate easily. They are planning to show a demo at Devconnect, but based on GitHub activity they may need additional support.</p><p>1. The roadmap lists several stakeholders (Wonderland, EF, Ambire, PSE, Helios, etc.), but GitHub repos show contributions mainly from 3 EF members and 2 Wonderland developers.<br>2. The GitHub repos are separate and not in a monorepo; they seem to use the Ambire structure, which may be sufficient for now.</p>",
    "logo": "/logos/wallets/kohaku.jpg",
    "pros": [
      "EF's support: multiple stakeholders are interested in participating",
      "Neutral architecture: will implement various privacy protocols",
      "Modularity: plugin/SDK design allows wallets to integrate only the privacy modules they need",
      "EF coordination: potential to align privacy R&D across wallets, dApps, and infra teams",
      "Beyond on-chain privacy: includes metadata/network/front-end protections such as Helios light client integration, P2P transaction broadcasting, per-dApp account isolation, ZK-based recovery, identity modules (ZKEmail, ZKPassport, Anon Aadhaar), and PQ signature fallback mechanisms"
    ],
    "cons": [
      "Not production ready: still in early development",
      "Complex third-party integration: wallet teams may struggle to adopt Kohaku",
      "Fragmentation across protocols: multiple privacy systems (Railgun, stealth addresses, Privacy Pools) may split user funds across domains"
    ]
  },
  {
    "title": "Arcane Wallet",
    "category": "Wallets",
    "website": "https://docs.0x0.ai/0x0-ecosystem/arcane-privacy-wallet",
    "description": "<p>A stealth addresses wallet that focuses on three main components:</p><ol><li><strong>Stealth Addresses:</strong> Arcane Wallet generates unique stealth addresses for each transaction, ensuring that the recipient’s identity remains hidden on-chain. This prevents third parties from tracing transactions back to a recipient’s public key.</li><li><strong>Enhanced Privacy:</strong> Using ephemeral keys and shared secrets, only the intended recipient can recognize and access the transaction. View tags act as identifiers to help the recipient scan and detect incoming transfers.</li><li><strong>User Experience:</strong> Arcane Wallet offers a familiar UX similar to traditional wallets while adding privacy features. Users can send and receive funds without needing to understand underlying cryptography.</li></ol>",
    "logo": "/logos/wallets/arcane.avif",
    "pros": [
      "Privacy amount: the transacted amount is public because transactions are published on-chain",
      "Private recipient: each transaction uses a fresh stealth address, hiding recipient identity and history",
      "Public sender: sender reveals their public address unless using stealth addresses; Arcane UI uses stealth addresses to avoid leakage",
      "ERC-20 compatibility: supports shielding and private transfers of any ERC-20 token",
      "Modularity / Composability: tokens can be shielded in Arcane and unshielded to any wallet for DeFi/dApp usage",
      "Gasless transactions: relayers sponsor gas in exchange for token-denominated fees to avoid leaking sender gas-address",
      "Compliance: viewing key allows users to selectively disclose transactions"
    ],
    "cons": [
      "Relayers metadata leakage: relayers may correlate users via metadata such as timing or IP",
      "No easy adaptability: stealth-address logic differs from normal transfers, possibly causing UX friction",
      "Anonymity set: low usage reduces privacy and makes metadata correlation more feasible",
      "Public leaderboard: anonymous IDs with transaction volumes may imply internal address-linking capabilities"
    ]
  },
  {
    "title": "Umbra Cash",
    "category": "Stealth Addresses",
    "website": "https://app.umbra.cash/",
    "description": "<p>Private transfers are limited in scope — the goal is to obfuscate the recipient address on-chain so that only the sender and receiver know who was paid. However, it does not hide amounts, senders, or full transaction context.</p><p><strong>It's achievable by using:</strong></p><ol><li><strong>Stealth addresses</strong> – ephemeral addresses generated by combining a random number and the recipient’s public key</li><li><strong>Two keypairs</strong> – users derive a spending key and viewing key from a signed message</li><li><strong>On-chain key registry</strong> – public keys for stealth address generation are published on-chain</li><li><strong>Encrypted announcement events</strong> – sender emits encrypted data so the recipient can detect funds</li><li><strong>Blockchain scanning</strong> – recipients monitor Umbra contract events and use their viewing key to detect payments</li></ol>",
    "logo": "/logos/stealth-addresses/umbra-cash.jpg",
    "pros": [
      "Sender-to-receiver unlinkability – observers cannot see who received funds",
      "Ethereum-native – works directly on Ethereum without new chains or exotic components",
      "No trusted setup – uses ECC and signed messages rather than SNARKs",
      "Optional relayers – supports gasless withdrawals via meta-transactions"
    ],
    "cons": [
      "Not full privacy – sender and amount remain visible on-chain",
      "Limited anonymity set – depends on how many valid recipients are registered",
      "Recipient hygiene – withdrawing from the stealth address to a known address breaks privacy",
      "On-chain key registration – may leak metadata if keys are linked to identities",
      "Privacy degrades with heuristics – timing, withdrawal patterns, and registry activity can weaken unlinkability"
    ]
  },
  {
    "title": "Fluidkey",
    "category": "Stealth Addresses",
    "website": "https://fluidkey.com/",
    "description": "<p>Private transfers are partial — Fluidkey uses stealth addresses to decouple your public identity from the address you receive funds to. However, it does not provide full privacy (e.g. hiding senders or amounts).</p><p><strong>It’s achievable by using:</strong></p><ol><li><strong>Account setup and key derivation</strong> – wallet signs a message to derive spending and viewing keys; public keys are published on-chain.</li><li><strong>Public key lookup by payer</strong> – sender finds spending/viewing public keys and generates a random scalar r.</li><li><strong>Stealth address generation and encryption</strong> – sender computes a stealth address using spending key + r; r is encrypted with the viewing key and emitted in an Announcement event.</li><li><strong>Sending funds and announcement</strong> – sender transfers funds to the stealth address; Announcement event includes encrypted r.</li><li><strong>Receiver scans announcements</strong> – receiver decrypts r using viewing key, computes stealth private key, and detects payments.</li><li><strong>Withdrawal / use of funds</strong> – receiver withdraws using the stealth key or via relayer for gasless UX.</li></ol>",
    "logo": "/logos/stealth-addresses/fluidkey.jpg",
    "pros": [
      "Recipient anonymity – stealth addresses hide which public identity received funds",
      "Ethereum-native – works entirely within the EVM ecosystem",
      "No zero-knowledge proofs or heavy crypto – simpler design than ZK-based systems",
      "Better UX via relayers – supports gasless withdrawals through meta-transactions"
    ],
    "cons": [
      "Limited privacy – sender, amount, and metadata remain visible; only recipient link is hidden",
      "Anonymity set considerations – small user base weakens privacy",
      "Recipient hygiene matters – moving funds to a known address breaks privacy",
      "Public key registration leaks metadata – ties spending/viewing keys to on-chain identities",
      "Smart contract risks / gas cost – interacting with the contract or relayers introduces overhead and assumptions"
    ]
  },
  {
    "title": "Curvy",
    "category": "Stealth Addresses",
    "website": "https://curvy.box/",
    "description": "<p>Private transfers are enabled by obfuscating recipient identity on-chain using stealth addresses and cryptographic primitives. It emphasizes sender-to-recipient unlinkability, not full transaction anonymity (amounts and senders are visible).</p><p><strong>It’s achievable by using:</strong></p><ol><li><strong>Stealth addresses</strong> – ephemeral addresses generated using recipient public keys and a unique nonce</li><li><strong>Two keypairs</strong> – derived from a Curvy ID: a spending key and a viewing key</li><li><strong>On-chain key registry</strong> – users register public keys to receive stealth payments</li><li><strong>Encrypted signals</strong> – senders post encrypted announcements detectable only by the intended recipient</li><li><strong>Blockchain scanning</strong> – users monitor Curvy events to detect incoming payments using their viewing key and tag for fast scanning</li></ol>",
    "logo": "/logos/stealth-addresses/curvy.png",
    "pros": [
      "Recipient privacy – hides recipient identity on-chain",
      "No trusted setup – relies on standard cryptographic assumptions of pairings and elliptic curves",
      "Efficient scanning – tag system allows fast event detection without scanning all transactions",
      "Wallet-native – integrates with existing EVM wallets via SDK"
    ],
    "cons": [
      "View tag leakage / tag collisions – truncated fingerprints risk collisions or enumeration attacks; 64-bit tags work for millions but not billions",
      "Anonymity set constraints – privacy depends heavily on user adoption and registry size",
      "Metadata registration linking – published keys may link to identities if correlated externally",
      "Heuristic and timing correlation – timing, gas, and behavioral patterns may reduce anonymity"
    ]
  },
  {
    "title": "Plasma Fold (PSE)",
    "category": "Privacy L2s",
    "website": "https://pse.dev/projects/plasma-fold",
    "description": "<p>A scalable off-chain computation L2 that allows high-speed client-side proving while minimizing on-chain data. Users can generate proofs directly on their devices and contribute to the L2. It uses a UTXO-based design so users can incrementally prove their balances over time using Incrementally Verifiable Computation (IVC).</p>",
    "logo": "/logos/private-l2s/pse-horizontal-white.png",
    "pros": [
      "Sender privacy: UTXO + client-side zk proofs hide sender balance and movements",
      "Recipient privacy: incremental balance model hides recipient balance and movements",
      "Amount privacy: only sender and recipient know the amount; only a correctness proof is public",
      "Censorship resistance: zk proofs can be submitted directly if sequencer censors transactions",
      "Audit / selective disclosure: users can selectively reveal specific UTXOs for compliance",
      "Composability: L2 entry for private transfers and L1 exit for public DeFi/NFT/trading",
      "Compliance: Proof-of-Innocence and selective disclosure of UTXOs possible"
    ],
    "cons": [
      "No modularity: system is designed specifically for private transfers and requires entering/exiting the L2",
      "Client-side proving: currently immature and challenging for seamless UX; IVC research aims to improve this",
      "UTXOs kept locally: users must store UTXOs securely to maintain access to their balances",
      "Still in research: no production-ready implementation yet"
    ]
  },
  {
    "title": "Intmax",
    "category": "Privacy L2s",
    "website": "https://intmax.io/#about",
    "description": "<p>A stateless L2 providing privacy and performance. The block producer (sequencer) sends each user a proof of balance after every transaction; users sign and store these proofs locally. To send funds, a user combines the stored proof with a new zk proof authorizing spending, then sends the proof to the recipient, who verifies it and requests a fresh balance proof from the sequencer.</p><p>To increase proving efficiency, Intmax uses cyclic recursive ZKPs, so only the latest ZKP needs to be verified to validate the entire chain of transactions. Plasma Fold inherits several design elements from Intmax.</p>",
    "logo": "/logos/private-l2s/intmax.jpg",
    "pros": [
      "Sender privacy: UTXO + client-side zk proofs hide sender balance and movements",
      "Recipient privacy: local incremental balance model hides recipient balance and movements",
      "Amount privacy: only sender and recipient know the amount; only a correctness proof is visible",
      "Censorship resistance: zk proofs can be submitted directly if sequencer censors transactions",
      "Audit / selective disclosure: users may selectively reveal specific UTXOs for compliance",
      "Composability: requires entering L2 for private transactions and exiting for public L1 activity",
      "Compliance: Proof-of-Innocence and selective UTXO disclosure are possible",
      "Production-ready: Intmax L2 launched in June 2025 (stage 0 per L2Beat)"
    ],
    "cons": [
      "Not mature enough: recently launched and based on untested fresh research",
      "No modularity: system is specifically designed for private transfers and requires entering/exiting the L2",
      "Client-side proving: not mature enough for seamless UX",
      "UTXOs kept locally: users must securely store UTXOs to maintain access to balances"
    ]
  },
  {
    "title": "Scroll Cloak",
    "category": "Privacy L2s",
    "website": "https://scroll.io/blog/introducing-cloak",
    "descriptio": "<p>A zk-validium that posts zk-proofs of correct state transitions to a settlement layer (Scroll). Only proofs are posted on-chain, not underlying data. Off-chain providers handle data availability, making it similar to a rollup but without the ability to withdraw from the settlement layer. Cloak supports EVM-compatible smart contracts and tooling.</p><p>Only the off-chain provider (RPC gateway + sequencer) can see all movements—similar to traditional banking, where operators see all internal activity but users don't see each other’s data. Cloak achieves confidentiality through fine-grained access control: sequencers and regulators can access data, while users can only access their own accounts.</p>",
    "description": "<p>It is a zk-validium: post zk-proofs of correct state transition to a settlement layer that in this case is Scroll (could be considered a L3). It posts only proofs and not the data itself. Data can be handled to off-chain providers not related to Ethereum. It is like a rollup but without the ability to withdraw funds from the settlement layer (aka L1 or in this case Scroll). Cloak allows for EVM-compatible smart contracts and tooling.</p><p>Only the off-chain provider in charge of the RPC gateways and the sequencer can see all movements (similar to how banking system work nowadays. They can see all transactions inside the system but they decide to maintain privacy between users).</p><p>Cloak achieves confidentiality via fine-grained access control. This allows only chain operators (sequencers) and regulators to access the data. Users can freely access their own accounts, but they cannot query other users' data.</p>",
    "logo": "/logos/zkWormholes/scroll.jpg",
    "pros": [
      "Private balances: users can see only their own balance, similar to traditional banking",
      "Public sender and receiver: EVM-compatible structure, but transactions themselves are private since only proofs are posted",
      "Gas efficient: sequencer posts only zk-proofs, enabling high throughput and low gas",
      "Easy integration: works smoothly within the Scroll L2 ecosystem",
      "Powering a stablecoin: the private stablecoin USX is being developed using Cloak"
    ],
    "cons": [
      "Permissioned: this zk-validium technology is permissioned, it means that there is a central authority that manages all the state and can see all the transactions (no privacy at all). The system assumes that this authority is honest and will not leak private info. It feels like corporate private blockchains",
      "Censorship: central sequencer could block or censor user transactions",
      "Immature ecosystem: Scroll ecosystem is still small with few mature applications; stability and UX concerns cited"
    ]
  },
  {
    "title": "Miden",
    "category": "Privacy L2s",
    "website": "https://miden.xyz/resource/blog/vision",
    "description": "<p>Users execute their own transactions locally and store their own state. ZK proofs of valid transactions reach the chain, where nodes verify compact proofs representing thousands or millions of valid transactions. This breaks the usual correlation between usage growth and performance limits, making privacy the default. Most transactions are executed and proven by users, so the network no longer needs to re-execute them.</p><p>Edge execution also removes limits on smart contract complexity. ZK proofs are exponentially faster to verify than the computations they represent. From the network’s perspective, a proof of a simple transfer and a proof of a massive ML computation are nearly equivalent to verify. Smart contract complexity is limited only by user hardware, not gas limits.</p>",
    "logo": "/logos/private-l2s/miden.png",
    "pros": [
      "Private balances: UTXO model prevents outsiders from knowing a user's balance",
      "Private recipient: receiving a transfer reveals nothing to the sender or public; only a zk-proof is visible",
      "Private sender: only participants know sender/recipient; proofs reveal no balance or past activity",
      "Scalable: users generate proofs locally; mobile or large hardware can be used depending on need",
      "Censorship resistance: zk proofs can be submitted directly if sequencers censor transactions",
      "Compliance compatible: users can selectively reveal specific UTXOs to authorities"
    ],
    "cons": [
      "Deployment complexity: edge blockchains like Miden, PlasmaFold, and Aztec are still in research and not battle-tested",
      "Local storage: users must store their UTXOs and maintain local state",
      "L2 private transfers: system exists outside main EVM ecosystem; bridging is required for interaction with EVM dApps"
    ]
  },
  {
    "title": "Aztec",
    "category": "Privacy L2s",
    "website": "https://docs.aztec.network/developers/docs/concepts",
    "description": "<p>This is the GOAT L2 (and potentially a future L1). Aztec combines edge blockchains (private state) with public blockchains (public state) in the Aztec Virtual Machine (AVM). The private state is a chain of note hashes with a nullifier tree, stored locally by users to ensure full privacy of transfers and execution.</p><p>The public state is an EVM-like environment. Private functions can call public functions, but public functions cannot call private ones. Private state is computed locally, a proof is generated, and then submitted to the public state for global state updates.</p>",
    "logo": "/logos/private-l2s/aztec.jpg",
    "pros": [
      "Sender privacy: UTXO + client-side zk-proofs hide sender balance and movements",
      "Recipient privacy: local balance system hides recipient balance and movements",
      "Amount privacy: only sender and recipient know the transferred amount; only a correctness proof is public",
      "Censorship resistance: zk proofs can be submitted directly; sequencer decentralization underway",
      "Audit / selective disclosure: users can show specific UTXOs without revealing full state",
      "Composability: requires entering L2 for private actions, exiting to L1 for public DeFi/NFT/etc.",
      "Compliance: selective disclosure enables individual transaction audits without revealing full state",
      "Research-focus: Aztec drives cutting-edge work on edge blockchains and client-side proving",
      "Ethereum-aligned: shares ethos of decentralization with EF",
      "Native cross-chain communication: integrates L1 dApps directly with Aztec ecosystem",
      "Growing community: strong developer traction, especially through Noir DSL for private/public contracts"
    ],
    "cons": [
      "Different Virtual Machine: AVM is not EVM, requires learning Noir and new paradigms; some dev friction",
      "Research phase: still under heavy R&D, which may deter risk-averse institutions",
      "Winner choosing: working on Aztec means betting on one L2; could be seen as ecosystem fragmentation"
    ]
  },
  {
    "title": "Horizen",
    "category": "Privacy L2s",
    "website": "https://horizen-2-docs.horizen.io/",
    "description": "<p>Horizen is an EVM L3 powered by op-enclave, built on top of Base L2, one of the highest-performance L2s in the Ethereum ecosystem. OP-enclave is a modified OP Stack that leverages Trusted Execution Environments (TEEs) for state transition proofs.</p><p>This model uses TEEs to isolate and encrypt computation, letting developers deploy privacy-preserving applications without needing advanced cryptography knowledge. It is unclear exactly how the design works, but it appears similar to ZKP, FHE, and MPC coprocessor architectures (e.g., Zama, Fhenix). They use zkVerify as a proof provider.</p><p>Their whitepaper: https://downloads.horizen.io/file/web-assets/Horizen-2.0-Whitepaper.pdf</p>",
    "logo": "/logos/private-l2s/horizen.jpg",
    "pros": [
      "Private balance: FHE design hides balances between users, but the L3 operator can see balances",
      "Sender privacy: sender address remains visible",
      "Receiver privacy: recipient address remains visible",
      "Off-chain co-processor: FHE and TEE computations happen off-chain; sequencer posts only state zk proofs",
      "Built on Base: inherits speed and benefits from Base ecosystem demand",
      "Old player in privacy: team has experimented with privacy systems since 2017",
      "Grants and funding: Horizen offers developer grants for building on their network",
      "Compliance: supports selective decryption due to maintaining the FHE private key"
    ],
    "cons": [
      "External trust assumption: sequencer runs in AWS TEEs, which are known to be vulnerable in some attack scenarios",
      "Lack of documentation: unclear guidance for building privacy apps; TEEs mentioned inconsistently between docs and whitepaper",
      "Not mature ecosystem: few notable dApps currently deployed; indicates early-stage environment"
    ]
  },
  {
    "title": "Coti",
    "category": "Privacy L2s",
    "website": "https://docs.coti.io/coti-documentation/how-coti-works/introduction/garbled-circuits",
    "description": "<p>They use Garbled circuits to run their EVM L2. In the field of secure multi-party computation (MPC), a garbling protocol enables two or more parties to jointly compute a function while keeping both their inputs and intermediate variables private. Introduced initially in the 1980s, garbling protocols have become a cornerstone for privacy-preserving technologies.</p><p>In the context of COTI V2, garbling protocols offer a revolutionary approach to handling transactional privacy. They can enable transactions and smart contract executions where the details (such as the amount of funds transferred, or the specific conditions of the contract) remain private between the involved parties. This level of privacy is particularly important in decentralized finance applications where transaction confidentiality can be as critical as transaction integrity.</p><p>COTI V2’s use of garbling protocols takes a completely novel approach. Unlike ZK solutions which support a single data source (or owner), and are expensive on the client side, garbling protocols enable computation on private data coming from many sources (or owners). Furthermore, they’re able to maintain private storage in addition to Ethereum’s standard public global state.</p>",
    "logo": "/logos/private-l2s/coti.jpg",
    "pros": [
      "Private amount: garbled circuits keep transfer amounts private",
      "Private sender: sender identity remains visible (standard smart contract transaction)",
      "Private recipient: recipient identity remains visible (standard smart contract transaction)",
      "Garbled circuits: novel MPC-style approach enabling confidential computation across multiple parties",
      "Good docs and examples: reference implementation for private token transfers available in public repos"
    ],
    "cons": [
      "Research phase: few real-world deployments of garbled circuits in Web3; maturity and battle-hardening unclear",
      "Metadata leakage: depending on implementation, observing encrypted value exchanges may leak partial information"
    ]
  },
  {
    "title": "Nightfall",
    "category": "Privacy L2s",
    "website": "https://github.com/EYBlockchain/nightfall_4_CE/blob/master/doc/nf_4.md",
    "description": "<p>A zk-rollup developed for privacy and focused on institutions. A private transaction works as follows:</p><ol><li>Privacy via commitments: on-chain data doesn’t reveal sender, recipient, or amounts.</li><li>Deposits move value from L1 into L2 (escrow) and create private commitments.</li><li>Transfers spend private commitments and create new ones for recipients.</li><li>Withdrawals spend commitments and de-escrow funds back to an L1 address.</li><li>Proposers generate rollup proofs; on-chain transactions appear uniform.</li></ol><p><strong>What the proofs assert:</strong></p><ol><li>Spend correctness: inputs belong to sender and are available to spend.</li><li>Value conservation: inputs = outputs + fee, enforced in-circuit.</li><li>Output formation: new output commitments are computed from recipient data and randomness using Poseidon hash.</li><li>Double-spend prevention: nullifiers derived from secret data prevent re-spending.</li><li>State transition: Merkle roots update correctly with nullified inputs and new commitments.</li></ol>",
    "logo": "/logos/private-l2s/nightfall.png",
    "pros": [
      "Sender privacy: UTXO + client-side zk proofs hide sender balance and movements",
      "Recipient privacy: incremental balance model hides recipient data",
      "Amount privacy: only sender and recipient know the amount; only correctness proofs are public",
      "Censorship resistance: zk proofs can be posted directly if sequencer censors users",
      "Audit / selective disclosure: users can reveal specific UTXOs for compliance without exposing full history",
      "Composability: users must enter the L2 for private actions and exit for public DeFi/NFT usage",
      "Compliance: Proof-of-Innocence and selective disclosure possible",
      "Institutional approach: EY Blockchain focuses on enterprise-grade integrations"
    ],
    "cons": [
      "External trust assumption: sequencer must remain live and uncensored",
      "Not mature enough: edge blockchain model is still early and untested",
      "No modularity: requires full L2 entry/exit, not easily integrated with existing systems",
      "Client-side proving: still immature and heavy for smooth UX",
      "UTXOs kept locally: users must store their own UTXOs securely",
      "Closed source: core Nightfall L2 appears not fully open; public repo only for Community Edition",
      "Huge infrastructure requirements: sequencer reportedly needs 144 cores and 750GB RAM"
    ]
  },
  {
    "title": "Ten Protocol",
    "category": "Privacy L2s",
    "website": "https://docs.ten.xyz/docs/introduction/features",
    "description": "<p>A Layer 2 using Trusted Execution Environments (TEEs) to create an encrypted EVM where only network nodes can see and execute transactions. Ten reintroduces data-access control to Web3, allowing compliance and secure execution (e.g., mitigating MEV). Smart contracts today can restrict who can write data, but not who can read it—Ten aims to fix this fundamental limitation.</p>",
    "logo": "/logos/private-l2s/ten.jpg",
    "pros": [
      "Private balance: confidential ERC-20 tokens can be implemented natively on Ten",
      "Private sender: sender address is public but balances remain private",
      "Private recipient: recipient address is public but balances remain private",
      "Efficiency: encrypted computation happens off-chain with no high gas costs or complex coprocessors",
      "Access-control at protocol level: configurable access policies enable regulator visibility where needed"
    ],
    "cons": [
      "External trust assumption: users must trust TEEs for liveness and censorship-resistance",
      "Access-control risks: authorities or central parties may be able to view encrypted balances without user consent",
      "TEEs vulnerabilities: known exploits could leak encrypted balance data; a malicious node could break the TEE locally",
      "Infrastructure costs and challenges: TEEs typically run on cloud providers, creating cost and liveness risks"
    ]
  },
  {
    "title": "INCO",
    "category": "Privacy L2s",
    "website": "https://www.inco.org/",
    "description": "<p>Inco stands for \"incognito\". It is currently TEE-based and provides an encrypted private EVM. Developers can write normal Solidity and import Inco libraries for encrypted data types and operations. A live demo exists for private transactions on Base Sepolia. Inco plans to migrate to INCO Atlas, an encrypted execution environment using FHE + MPC.</p><p>They published a Confidential ERC20 Framework whitepaper with Circle (USDC). Confidential transfers use FHE and ZKPs:</p><ol><li>ERC20 tokens are deposited into an escrow pool.</li><li>Confidential ERC20 tokens are minted on the INCO state.</li><li>Transfers use homomorphic operations over encrypted balances.</li></ol>",
    "logo": "/logos/private-l2s/inco.jpg",
    "pros": [
      "Amount privacy: transferred amounts are hidden via TEEs (now) or FHE (future)",
      "Sender & recipient privacy: sender/recipient addresses remain visible but balances are encrypted using FHE",
      "Audit / selective disclosure: users generate view keypairs; TEEs re-encrypt balances for authorized auditors",
      "Compatibility / composability: private tokens can be deployed on any EVM chain",
      "Deployment complexity: requires no protocol changes; can be deployed on any EVM quickly",
      "Strong partnerships: published encrypted ERC-20 framework with Circle (USDC)",
      "Faster provider: TEEs offer faster performance than pure FHE/MPC systems"
    ],
    "cons": [
      "External trust assumption: users must trust TEE providers today and FHE/MPC nodes in the future",
      "TEEs vulnerabilities: known exploits may leak encrypted balances; malicious node could break TEE locally",
      "Anonymity set: confidentiality depends on large user base; small usage weakens privacy",
      "Metadata leakage: timing, frequency, and behavioral patterns may still leak information",
      "Central disclosure: implementations may allow authorities or privileged parties to decrypt balances",
      "Infrastructure costs and challenges: TEEs often run on cloud providers, introducing cost and liveness risks"
    ]
  },
  {
    "title": "Prividiums",
    "category": "Privacy L2s",
    "website": "https://www.zksync.io/prividium",
    "description": "<p>These L2 sequencers receive transactions from users, generate blocks, store data locally, and post only zk proofs to Ethereum. This provides privacy without requiring third-party infrastructure beyond the organization’s sequencer. Prividiums include interoperability mechanisms enabling them to communicate privately and trustlessly, performing atomic swaps between chains.</p><p><strong>A Prividium includes:</strong></p><ol><li>High-throughput off-chain execution environment</li><li>Local or cloud-based data store</li><li>ZK prover generating proofs</li><li>Smart contract on Ethereum verifying proofs and anchoring finality</li></ol>",
    "logo": "/logos/private-l2s/prividiums.jpg",
    "pros": [
      "Balance privacy: external parties cannot see balances, though operator can (useful for compliance)",
      "Sender privacy: only the operator can view sender data",
      "Buyer privacy: only the operator can view buyer/recipient data",
      "Low computation costs: lightweight infrastructure due to L2 nature",
      "Compliance: regulators can request access to Prividium data for auditing",
      "Interop mechanism: supports private cross-chain token transfers via ZK-verified Merkle logs and coordinated proofs"
    ],
    "cons": [
      "Liveness: centralized sequencer must remain online at all times",
      "Operator oversight: sequencer can view all unencrypted data, similar to banking trust models",
      "Censorship: single sequencer can censor transactions; decentralization planned but not implemented",
      "Velocity: throughput depends entirely on operator’s infrastructure capacity"
    ]
  },
  {
    "title": "Payy Network",
    "category": "Privacy L2s",
    "website": "https://polybase.github.io/zk-rollup/whitepaper.pdf",
    "description": "<p>An Ethereum L2 zk-rollup using a UTXO architecture to prioritize private transfers and compliance. Using UTXO notes and zk proofs, users can privately transact as if exchanging cash notes. User A sends a UTXO note to User B via a secure P2P channel or encrypted registry, while submitting a zk proof to the sequencer validating the note.</p><p><strong>Compliance mechanisms:</strong></p><ol><li><strong>Transaction lineage</strong> – full or partial lineage tracking to disable illicit funds without revealing details.</li><li><strong>Privacy pools</strong> – grouping actors into good/bad pools for risk-based filtering.</li><li><strong>Compliance ZK proofs</strong> – proving compliance constraints without revealing private data.</li></ol>",
    "logo": "/logos/wallets/payy.jpg",
    "pros": [
      "Private balance: only sender and receiver know the amount being transacted",
      "Sender privacy: sender reveals only the spent UTXO, not their remaining UTXOs",
      "Receiver privacy: receiver stores the UTXO privately; sender cannot infer any additional balance data",
      "Compliance: strong model ('guilty until proven innocent') integrating lineage, pools, and ZK proofs",
      "Offline recipient support: encrypted UTXO can be stored on-chain for later retrieval and decryption",
      "Decentralized sequencer network: staking-based system rotates block proposers and slashes inactivity"
    ],
    "cons": [
      "Compatibility / modularity: L2 only supports private transfers; no smart contracts or dApp compatibility",
      "Communication observer risk: P2P note exchange could be monitored, leaking metadata about transactions"
    ]
  },
  {
    "title": "ZEXE",
    "category": "Research",
    "website": "https://medium.com/@youssef.housni21/zexe-zero-knowledge-execution-ca616e87a3a9",
    "description": "<p>ZEXE (Zero-Knowledge EXecution) is a cryptographic framework introduced in 2018 by ZCash researchers to enable users to execute smart contract functions locally and post only a proof on-chain. It aims to bring privacy-preserving smart contract execution to blockchains like ZCash. The approach inspired modern edge-blockchain designs such as Miden and Aztec, where computation is client-side and chains verify succinct proofs.</p><p>To guarantee correctness and confidentiality of arbitrary user-defined smart contract functions, the authors introduce the Record Nano-Kernel (RNK), a minimal operating system that:</p><ol><li>Provides process isolation</li><li>Determines data ownership</li><li>Handles inter-process communication</li></ol>",
    "logo": "/logos/private-l2s/pse-horizontal-white.png",
    "pros": [
      "Private balances: client-side execution combined with on-chain proofs hides transaction amounts",
      "Private sender and receiver: identities remain private since only proofs are posted",
      "Modularity: later systems (e.g., Aztec) show private and public smart contract states are possible"
    ],
    "cons": [
      "Client-side proving: still expensive and slow for mainstream mobile or desktop UX",
      "Research only: no L2 implements ZEXE directly; serves as conceptual foundation for edge blockchains like Miden and Aztec"
    ]
  },
  {
    "title": "Monero",
    "category": "Alternative L1s",
    "website": "https://www.getmonero.org/",
    "description": "<p>Private transfers are enabled by default: amounts, receivers, and senders are not visible.</p><p><strong>It's achievable by using:</strong></p><ol><li><strong>Bulletproofs</strong> — ensure output amounts are non-negative</li><li><strong>Ring signatures</strong> — multiple outputs are provided but only one is valid (Monero uses a UTXO-like model)</li><li><strong>Wallet integration</strong> — wallets scan new transactions and try to decrypt them using the view key</li><li><strong>Two keypairs</strong> — spend keypair and view keypair</li><li><strong>Stealth addresses</strong> — many unlinkable addresses can be derived from a master address</li></ol>",
    "logo": "/logos/alternative-l1s/monero.jpg",
    "pros": [
      "Default privacy: no need for third-party tools or custom UX",
      "Untraceable: transactions cannot be linked to identities or wallets",
      "Mature cryptography: conservative design with battle-tested primitives"
    ],
    "cons": [
      "Regulatory pressure: difficult to implement compliance or KYC due to lack of smart contracts",
      "Transaction size: transactions are large and slower to verify",
      "No smart contracts: cannot build dApps on Monero"
    ]
  },
  {
    "title": "ZCash",
    "category": "Alternative L1s",
    "website": "https://z.cash/",
    "description": "<p>Private transfers are optional: amounts, receivers, and senders are hidden only for shielded transactions. ZCash uses zk-SNARKs to achieve this.</p><p><strong>It's achievable by using:</strong></p><ol><li><strong>zk-SNARKs</strong> – private verification of transaction data without revealing it</li><li><strong>Shielded addresses (z)</strong> – fully private transactions</li><li><strong>Transparent addresses (t)</strong> – public, similar to Ethereum addresses</li><li><strong>Selectively disclosure</strong> – viewing keys allow auditors to inspect private data</li><li><strong>Sapling & Halo 2</strong> – improve efficiency and remove trusted setup</li><li><strong>Wallet integration</strong> – similar scanning model to Monero</li><li><strong>Two keypairs</strong> – spend keypair and view keypair</li></ol><p><strong>Types of transfers:</strong></p><ol><li><strong>t → t</strong> – fully transparent</li><li><strong>t → z</strong> – sender visible, receiver private</li><li><strong>z → z</strong> – full privacy</li></ol>",
    "logo": "/logos/alternative-l1s/zcash.jpg",
    "pros": [
      "Strong privacy: zk-SNARKs provide full data hiding",
      "Selective transparency: viewing keys allow controlled disclosure",
      "Smaller transaction size: more efficient than Monero",
      "Audit-friendly: enables privacy while supporting institutional compliance"
    ],
    "cons": [
      "Privacy not default: optional privacy weakens overall anonymity",
      "Metadata leaks: mixing t and z patterns may reveal activity",
      "Limited ecosystem support: some wallets/exchanges don't support shielded transactions"
    ]
  },
  {
    "title": "Penumbra",
    "category": "Alternative L1s",
    "website": "https://guide.penumbra.zone/overview/privacy",
    "description": "<p>Private transfers are mandatory: all transactions are shielded by default. Sender, receiver, and amount are not visible on-chain. Penumbra uses zero-knowledge proofs to enable fully private balances and transfers.</p><p><strong>It's achievable by using:</strong></p><ol><li><strong>zk-SNARKs / ZK proofs</strong> – prove validity without revealing private data</li><li><strong>Shielded addresses</strong> – every user is in the shielded pool; no transparent mode exists</li><li><strong>No transparent mode</strong> – non-private transactions are not supported</li><li><strong>Selective disclosure</strong> – optional encrypted data reveal via viewing keys</li><li><strong>Viewing keys</strong> – fine-grained full-view or spend-view authorization</li><li><strong>Local proof generation</strong> – users create ZK proofs locally; chain only processes encrypted state transitions</li><li><strong>Ultra-light clients</strong> – optimized for private mobile/web wallets without full sync</li><li><strong>Decoupled state model</strong> – separates transaction vs. consensus state for privacy and scalability</li></ol>",
    "logo": "/logos/alternative-l1s/penumbra.jpg",
    "pros": [
      "Privacy by default: stronger privacy than opt-in systems like ZCash",
      "Cross-chain compatibility: supports private transfers for IBC assets (ATOM, OSMO, USDC, etc.)",
      "No address reuse issues: privacy-preserving address derivation prevents linkability",
      "Selective transparency: viewing keys allow granular compliance and auditing",
      "Efficient for wallets: optimized for low bandwidth and fast proof handling",
      "Integrated shielded DEX: private swaps and liquidity actions without leaking trading behavior"
    ],
    "cons": [
      "Complex architecture: privacy across consensus, staking, and IBC adds complexity",
      "Regulatory risk: strong privacy may face scrutiny in some jurisdictions",
      "Limited adoption: early ecosystem with fewer integrations compared to ZCash"
    ]
  },
  {
    "title": "Namada",
    "category": "Alternative L1s",
    "website": "https://namada.net/",
    "description": "<p>Private transfers are mandatory and asset-agnostic: amount, sender, and receiver are never visible within Namada’s Multi-Asset Shielded Pool (MASP). No transparent transactions exist.</p><p><strong>It's achievable by using:</strong></p><ol><li><strong>zk-SNARKs</strong> – validate transactions without revealing private data</li><li><strong>MASP (Multi-Asset Shielded Pool)</strong> – supports private transfers for any token, fungible or non-fungible</li><li><strong>Unified shielded address format</strong> – all assets share one anonymity set</li><li><strong>Selective disclosure</strong> – users generate viewing keys for auditors or trusted parties</li><li><strong>Viewing keys</strong> – read-only access for compliance or personal tracking</li><li><strong>Cross-chain asset support</strong> – private transfers for IBC assets and bridged Ethereum assets</li><li><strong>Shielded actions</strong> – enable private interactions with external applications and blockchains</li><li><strong>Shielding rewards</strong> – incentivize users to shield assets and increase the anonymity set</li></ol>",
    "logo": "/logos/alternative-l1s/namada.jpg",
    "pros": [
      "Privacy by default: no data exposed unless explicitly revealed",
      "Supports any asset: IBC and bridged assets can be shielded",
      "Unified anonymity set: all assets share the same pool, strengthening privacy",
      "Selective transparency: supports disclosures for compliance/auditing",
      "Shielding incentives: rewards users for contributing to privacy",
      "Cross-chain composability: provides privacy for Ethereum and Cosmos ecosystems",
      "Public Goods Funding (PGF): ecosystem development funded via inflation"
    ],
    "cons": [
      "Limited adoption: early-stage ecosystem with fewer integrations",
      "Metadata risk via bridging: cross-chain operations may leak metadata",
      "Complex user experience: viewing keys and ZK proofs add UX friction",
      "Regulatory risk: full privacy may attract regulatory scrutiny"
    ]
  },
  {
    "title": "Mina",
    "category": "Alternative L1s",
    "website": "https://minaprotocol.com/",
    "description": "<p>Private transfers are not the default: regular token transfers are public, but privacy-preserving applications (zkApps) can be built using zero-knowledge proofs. Mina’s primary value is lightweight zk programmability, not enforced private transfers. It functions mainly as a scalability and privacy-enabling platform rather than a private-transfer protocol.</p><p><strong>It's achievable by using:</strong></p><ol><li><strong>zk-SNARKs</strong> – recursive proofs keep the chain ~22 KB and enable private computation</li><li><strong>zkApps</strong> – smart contracts where sensitive data stays off-chain</li><li><strong>Local state execution</strong> – all private logic runs on the client</li><li><strong>Selective disclosure</strong> – apps reveal only necessary proof outcomes</li><li><strong>Verifiable computation</strong> – focus on proving statements about off-chain data</li><li><strong>Proof recursion</strong> – compose multiple zk proofs efficiently</li><li><strong>Ultra-light clients</strong> – full-node verification in browsers/phones</li></ol>",
    "logo": "/logos/alternative-l1s/mina.png",
    "pros": [
      "Lightweight by design: ~22 KB chain size enables universal verification",
      "Powerful privacy tooling: zkApps support application-specific privacy",
      "Data minimization: prove facts without revealing underlying data",
      "Recursive SNARKs: highly composable proof system",
      "Ideal for web use cases: strong for identity and credential applications"
    ],
    "cons": [
      "Privacy not default: token transfers remain public; no native private transfer layer",
      "Limited adoption: early-stage ecosystem with fewer integrations and dApps"
    ]
  },
  {
    "title": "Canton Network",
    "category": "Alternative L1s",
    "website": "https://www.canton.network/faq",
    "description": "<p>A privacy-focused L1 aimed at institutions and regulated financial entities. Canton provides selective visibility so that only parties who “need to know” see transaction details. Infrastructure nodes cannot inspect full transaction contents. Participants (e.g., banks, insurers) operate their own nodes containing only their users’ data, similar to real-world financial silos.</p><p><strong>How it works:</strong></p><ol><li>Smart contract validation and execution happen only on participant nodes directly involved in the transaction.</li><li>Sync domain operators (similar to validators/miners) handle ordering, timestamping, and coordination.</li><li>Transaction data is encrypted end-to-end; operators never access plaintext data.</li></ol>",
    "logo": "/logos/alternative-l1s/canton-network.jpg",
    "pros": [
      "Canton Wallet launch generated strong traction and positive reception",
      "Rewards program significantly boosted user onboarding and early growth"
    ],
    "cons": [
      "Permissioned blockchain: relies on trust in participant nodes not to leak data; not a trustless system"
    ]
  },
  {
    "title": "Dero",
    "category": "Alternative L1s",
    "website": "https://dero.io/",
    "description": "<p>Private transfers are the default: all transfers and smart contract interactions on Dero are private by design. Unlike opt-in privacy systems, Dero enforces confidentiality at the protocol level using homomorphic encryption. Its goal is to combine privacy, smart contracts, and scalability without compromising decentralization.</p><p><strong>It's achievable by using:</strong></p><ol><li><strong>Homomorphic Encryption</strong> – custom scheme enabling encrypted balances and transactions while still allowing verification</li><li><strong>Virtual Machine</strong> – smart contracts with encrypted inputs, state, and outputs</li><li><strong>Encrypted account model</strong> – avoids full-chain scanning by indexing encrypted balances</li><li><strong>Sigma-microblocks</strong> – frequent micro-block rewards improve miner participation and decentralization</li><li><strong>Instant balance lookups</strong> – encrypted balances are indexed for fast wallet queries</li><li><strong>AstroBWT</strong> – ASIC-resistant, CPU-friendly mining algorithm</li></ol>",
    "logo": "/logos/alternative-l1s/dero.jpg",
    "pros": [
      "Privacy by default: all transactions and contract activity are encrypted",
      "Encrypted smart contracts: confidential logic + data at the protocol layer",
      "Efficient balance checks: no full-chain scanning required",
      "No trusted setup: cryptography does not rely on a ceremony",
      "Resilient mining: AstroBWT supports decentralized, CPU-friendly mining"
    ],
    "cons": [
      "Complex, less-reviewed cryptography: DERO-HE lacks broad peer review compared to established ZK systems",
      "Smaller ecosystem: limited integrations, exchanges, and tooling",
      "High developer barrier: requires learning a unique VM and toolchain",
      "Potential privacy leaks: some researchers question the robustness of Dero's privacy model"
    ]
  },
  {
    "title": "DarkFi",
    "category": "Alternative L1s",
    "website": "https://dark.fi/",
    "description": "<p>Private, anonymous smart contracts and transactions are the default. All aspects of blockchain interaction are designed for complete anonymity, including transfers, contracts, and governance. DarkFi is a Layer 1 blockchain built with zero-knowledge proofs at its core.</p><p><strong>It's achievable by using:</strong></p><ol><li><strong>ZK-Proofs</strong> – anonymous transactions and smart contracts without revealing sender, receiver, or amount; zkas DSL used for circuit writing</li><li><strong>Anonymous account model</strong> – account-based but with hidden identities and balances</li><li><strong>Anonymous DAOs</strong> – governance with fully hidden participants and votes</li><li><strong>Anonymous atomic swaps</strong> – cross-chain swaps with no linkability</li><li><strong>Onion routing</strong> – Tor/I2P networking hides metadata and IP addresses</li><li><strong>Anonymous contracts & dApps</strong> – smart contracts written in DarkFi’s Rust-based language with default privacy</li><li><strong>No address reuse</strong> – stealth addressing and one-time keys prevent linkability</li></ol>",
    "logo": "/logos/alternative-l1s/darkfi.jpg",
    "pros": [
      "Default full-stack anonymity: networking, contracts, and transactions are private",
      "Smart contracts with privacy: private dApps and anonymous DAOs are natively supported",
      "Composable anonymous primitives: powerful building blocks for private applications",
      "Censorship-resistant: no compliance layers; fully user-controlled",
      "New cryptographic designs: modern ZK systems enabling flexible programmability"
    ],
    "cons": [
      "New cryptography: less battle-tested than Monero; risks from novel primitives",
      "Early-stage: limited adoption, infrastructure, and wallet support",
      "Regulatory attack surface: strong anonymity + finance attracts scrutiny",
      "Complexity: ZK contracts are harder to write, audit, and maintain",
      "Performance and scalability: ZK-heavy architectures face overhead at scale",
      "Custom circuit DSL (zkas): not audited and limited adoption"
    ]
  },
  {
    "title": "Umbra",
    "category": "Solana projects",
    "website": "https://docs.umbraprivacy.com/docs/introduction",
    "description": "<p>Umbra is a private transactions protocol combining multiple privacy techniques:</p><ol><li><strong>Non-linkable addresses</strong> created from a seed + nonce (deterministic stealth addresses)</li><li><strong>Relayers</strong> enabling new stealth addresses to execute claim transactions without needing SOL/ETH for gas</li><li><strong>Mixer pool</strong> where users can send tokens</li><li><strong>Encrypted token balances</strong> using elliptic curve cryptography, homomorphic encryption, and MPC</li></ol><p>Umbra encrypts all transfer amounts and balances. Every transfer amount is encrypted using the Rescue cipher, making values fully opaque to observers.</p>",
    "logo": "/logos/solana-projects/umbra.jpg",
    "pros": [
      "Balance privacy: transfer amounts and balances encrypted with the Rescue cipher; EC + HE + MPC provider improves proving efficiency",
      "Address unlinkability: deterministic stealth addresses prevent identity leakage and address reuse",
      "Potential for auditability: structured encryption allows selective disclosure of specific transaction proofs without revealing full history"
    ],
    "cons": [
      "Outsourced HE provider: MPC/HE network is operated by a third party (Arcium)",
      "Fragile n-of-n encryption threshold: if even one MPC node becomes unavailable or malicious, the whole protocol may halt"
    ]
  },
  {
    "title": "zk-locomotive (zkLambda)",
    "category": "Solana projects",
    "website": "https://github.com/zklambda#user-story",
    "description": "<p>A privacy-preserving file transfer system using zk proofs and encryption. The sender encrypts a file with the recipient’s public key, publishes the encrypted blob on-chain, and the recipient later downloads and decrypts it. The system also supports token transfers between networks (e.g. Ethereum → Solana) via the Wormhole bridge (not to be confused with zkWormholes / EIP-7503).</p>",
    "logo": "/logos/solana-projects/zk-lambda.png",
    "pros": [
      "Private balance & recipient: files/payloads are encrypted under the recipient’s public key; only they can decrypt the ciphertext",
      "Cross-chain interoperability: encrypted payloads or tokenized proofs can be bridged across networks using infrastructure like Wormhole"
    ],
    "cons": [
      "Lack of maturity: no new commits since March; demo interface shown but not functional",
      "Metadata leakage: CCIR public registry links wallet addresses to public keys; timing and network metadata may expose sender/receiver relationships without additional obfuscation"
    ]
  },
  {
    "title": "Arcium Network",
    "category": "Solana projects",
    "website": "https://docs.arcium.com/",
    "description": "<p>An encrypted computation network described as an 'encrypted supercomputer.' Arcium provides a decentralized MPC network using secret sharing and threshold encryption. Developers can run arbitrary computations over encrypted data without exposing inputs or intermediate values. Several privacy applications, such as Umbra on Solana, run on Arcium's MPC infrastructure. Elusiv, their previous shielded transfer protocol, is now discontinued and in withdraw-only mode.</p>",
    "logo": "/logos/solana-projects/arcium.jpg",
    "pros": [
      "General-purpose encrypted computation via MPC; developers can run arbitrary encrypted workloads",
      "Modular security configuration allowing developers to tune parameters like cluster size, MPC protocol, and security model",
      "Low barrier to entry for node operators with documented instructions for running Arcium MPC nodes",
      "Developer-friendly toolkit where Solana apps can annotate confidential functions without mastering cryptography",
      "Economic sustainability through staking/slashing using the ARX token",
      "Production usage: Umbra private transfers use Arcium as their MPC backend"
    ],
    "cons": [
      "External trust assumption: users must trust Arcium nodes for liveness, correctness, and censorship resistance",
      "Metadata leakage: timing, MPC cluster patterns, or invocation behavior may reveal correlations despite encrypted data",
      "Performance & cost constraints: MPC workloads can be heavy; large computations or high traffic can cause latency or bandwidth issues"
    ]
  },
  {
    "title": "Encifher",
    "category": "Solana projects",
    "website": "https://docs.encifher.io/docs/how-it-works",
    "description": "<p>Encifher encrypts user token balances using threshold ElGamal encryption. Encrypted balances are stored off-chain in a data-availability layer while on-chain programs handle only cryptographic pointers (hashes/commitments). Users see plaintext amounts locally, but the chain sees only encrypted balance transitions. The system uses ephemeral accounts to avoid address reuse and integrates with Jupiter DEX by exposing token identifiers for routing.</p>",
    "logo": "/logos/solana-projects/encifher.jpg",
    "pros": [
      "Private balances: encrypted swaps and transfers hide amount and recipient; on-chain interactions only see encrypted state transitions",
      "Ephemeral accounts improve unlinkability by preventing address reuse across operations",
      "Hybrid off-chain/on-chain design: heavy crypto handled by TEEs, while Solana programs manage lightweight pointer updates",
      "Near-native UX: encrypted SPL swaps aim to match normal Solana swap latency and gas profile",
      "Compliance support through Predicate and Chainalysis integrations"
    ],
    "cons": [
      "External trust assumption: relies on external provider availability and correctness for encrypted state resolution",
      "TEE reliance: TEEs have known vulnerabilities that could expose encrypted contents or private keys",
      "Unclear threshold key security: documentation lacks detail on key rotation, threshold parameters, and anti-collusion design",
      "Small anonymity set risk: low usage reduces privacy strength",
      "Metadata leakage: pointer updates, ephemeral account behavior, and timing patterns can expose side-channel information"
    ]
  },
  {
    "title": "Voidify",
    "category": "Solana projects",
    "website": "https://voidify.gitbook.io/whitepaper",
    "description": "<p>Voidify is a zk-based mixer on Solana. Users deposit SOL or SPL tokens from address A, generate a zero-knowledge proof that they deposited a specific amount, and later use that proof to withdraw to address B without linking the two addresses. The protocol uses Poseidon hashes for efficient zk-circuit performance, mirroring Tornado Cash but optimized for Solana.</p>",
    "logo": "/logos/solana-projects/voidify.jpg",
    "pros": [
      "Simplicity: fully on-chain implementation with no external dependencies",
      "Unlinkability: similar to Tornado Cash, deposits and withdrawals cannot be linked",
      "Multi-token support: supports SOL and various SPL tokens",
      "Compliance: Proof-of-Innocence integration to filter blacklisted or illicit funds",
      "Relayers: hide sender identity and enable gasless withdrawals"
    ],
    "cons": [
      "Anonymity set limitations: privacy weakens when few users deposit in a pool or denomination",
      "User hygiene requirements: improper usage (e.g., immediate withdrawal, address reuse) can compromise privacy"
    ]
  },
  {
    "title": "Bonsol",
    "category": "Solana projects",
    "website": "https://bonsol.sh/docs/tutorials/a-taste-of-bonsol",
    "description": "<p>Bonsol is a zk-prover framework built on top of Risc Zero, designed to enable private zk program execution on Solana. It allows developers to write applications with both public and private state using zero-knowledge proofs, verified by on-chain verifier programs deployed on Solana.</p>",
    "logo": "/logos/solana-projects/bonsol.jpg",
    "pros": [
      "General-purpose zk execution: enables arbitrary computations inside zk programs",
      "Solana integration: verifier programs deployed on Solana validate proofs on-chain",
      "Flexible public/private inputs: developers choose what is revealed or kept private"
    ],
    "cons": [
      "Not an end-to-end privacy protocol: limited real-world apps using Bonsol for private transfers",
      "Third-party trust assumption: introduces a zk proving coprocessor with its own risks",
      "DoS vulnerability: no node network or economic incentives, risking denial-of-service on heavy proof workloads"
    ]
  },
  {
    "title": "Privacy Cash",
    "category": "Solana projects",
    "website": "https://www.privacycash.org/",
    "description": "<p>Privacy Cash is a Tornado Cash–style mixer on Solana that supports SOL and SPL tokens. Users deposit tokens into a pool and later withdraw the same amount to a different address using zero-knowledge proofs, preventing observers from linking deposits and withdrawals. The system works entirely on-chain and supports compliance mechanisms such as Proof-of-Innocence.</p>",
    "logo": "/logos/solana-projects/privacy-cash.jpg",
    "pros": [
      "Simplicity: fully on-chain implementation with no external dependencies",
      "Unlinkability: deposits and withdrawals cannot be linked, similar to Tornado Cash",
      "Multi-token support: supports SOL and SPL tokens",
      "Compliance: integrates Proof-of-Innocence to filter illicit funds"
    ],
    "cons": [
      "Lack of documentation: only GitHub repo and audit PDFs available, no clear docs or guides",
      "Anonymity set limitations: low usage reduces privacy and increases linkability risk",
      "User hygiene requirements: improper usage (e.g., immediate withdrawal, address reuse) undermines privacy"
    ]
  },
  {
    "title": "Solana Confidential Balances",
    "category": "Solana projects",
    "website": "https://www.helius.dev/blog/confidential-balances",
    "description": "<p>A native Solana extension that introduces confidential balances using zero-knowledge proofs and threshold ElGamal encryption. Users deposit tokens into a shielded pool where balances and transfer amounts remain encrypted. Transfers occur between encrypted accounts while maintaining correctness through ZK range, equality, and validity proofs. A pending-state model prevents misuse before encrypted credits finalize, improving safety. Users can withdraw from the shielded pool at any time.</p>",
    "logo": "/logos/solana-projects/solana.jpg",
    "pros": [
      "Native integration: validators run confidential balance logic as part of the Solana runtime",
      "Private balances: amounts are encrypted using HE (ElGamal) + MPC",
      "Correct execution: ZK proofs ensure valid transfers without revealing amounts",
      "Pending model: prevents race conditions and front-running on encrypted balances",
      "Opt-in compliance: confidentiality level can be app-dependent"
    ],
    "cons": [
      "No SDK or wallet integration yet: only Rust CLI tooling available",
      "Pending audit: ZK ElGamal program disabled on mainnet/devnet until audit completes",
      "No private sender or recipient: only amounts/balances are hidden; addresses remain public",
      "Side-channel leakage: timing, frequency, pending→available transitions may leak metadata"
    ]
  }
]
